import json
import random
import time
import pygame
from utils import DefaultError
from json import JSONDecodeError
from utils.images import images

class TextureError(DefaultError):

    def __init__(self, errmsg):
        DefaultError.__init__(errmsg)

class Texture:
    """
    Class is used to manage animation and textures. when creating a Texture object give it the path of the image
    (default path is the texture folder) and it will automatically search for a file name like the image but with a
    .json suffix if it finds none the class will always return the loaded image. if it doeas however it will check for
    a following structure:
    {
    "time": 1
    "randomized": false,
    "random_start": false,
    "frames": [
            {
                "index": 5,
                "time": 1
            }
        ]
    }
    "time" is obligatory and determines the default timeout in seconds

    "randomized" is not obligatory and will shuffle all undeclared indexes in "frames". Is False by default

    "random_start" will try to break up the synchronisation between same animations by setting the time_reference back
    by a few seconds and thus starting from a random frame

    "frames" represents the flow in wich each image will be shown. the items inside the list must correspond to the
    stacked images inside the .png or it will throw a TextureError.the order of the items is the chronological order
    of the animation itself.The list itself must not be present. we will generate one using default times.same goes for
    the items inside the list. as long as the number of items is correct any missing argument inside can be autogenerated
    using default times and indexes.

    "index" represents the image index inside the stacked image.png

    "time" represents the timeout for this animation frame
    """

    def __init__(self, image: str, single_run=False, set_height=False):
        self.init_time = time.time()
        self.single_run = single_run
        self.iterations = 0
        self.image = None
        self.img_str = image
        self.stop = False
        self.seth_bool = False
        if set_height == False:
            pass
        else:
            self.seth_bool = True
            self.seth_value = set_height

        try:
            self.image = images[self.img_str]
        except Exception:
            raise TextureError(f'unable to load image "{self.img_str}" directory')
        self.has_json = True

        try:
            self.script = json.load(open("resources/textures/" + self.img_str + ".json"))

            self.height, self.width = self.image.get_height(), self.image.get_width()
            if self.seth_bool:
                # self.height, self.width = self.seth_value, self.image.get_width()
                self.frame_count = self.height // self.seth_value
            else:
                self.frame_count = self.height // self.width

            try:
                self.default_time = self.script['time']
            except Exception:
                raise TextureError(f'image JSON must have valid "time" attribute')

            try:
                self.randomized = self.script['randomized']
            except KeyError:
                self.randomized = False

            try:
                self.randomized = self.script['random_start']
            except KeyError:
                self.randomized = False

            self.single_loop_time = self.frame_count * self.default_time

            if self.seth_bool:
                self.images = [self.image.subsurface((0, self.seth_value * i, self.width, self.seth_value)) for i in
                               range(self.frame_count)]
            else:
                self.images = [self.image.subsurface((0, self.width * i, self.width, self.width)) for i in
                               range(self.frame_count)]

            try:
                self.frame_list = self.script['frames']
                print('made it here')

                if len(self.frame_list) != self.frame_count:
                    raise TextureError(
                        f'image number ({self.frame_count}) and script items ({len(self.frame_list)}) are incoherent')

                self.single_loop_time = 0
                empty = []
                for i in self.frame_list:
                    if 'time' not in i:
                        i['time'] = self.default_time
                    if 'index' not in i:
                        if self.randomized:
                            empty.append(self.frame_list.index(i))
                        else:
                            i['index'] = self.frame_list.index(i)

                if self.randomized:
                    indexes = random.sample(empty, len(empty))
                    for i in indexes:
                        self.frame_list[i]['index'] = empty[indexes.index(i)]

                for i in self.frame_list:
                    self.single_loop_time += i['time']
                self.init_time -= random.uniform(0, self.single_loop_time)

            except KeyError:
                self.frame_list = [{"index": i, "time": self.default_time} for i in range(self.frame_count)]

        except JSONDecodeError:
            self.has_json = False
            print(f'unable to find json for "{self.img_str}"')

    def get(self):
        """
        get is used to get the image to display. it will automatically pick the right one based on the time it was initialized
        :return:
        """
        if self.stop: return False
        if self.has_json:
            now = time.time()
            delta_time = now - self.init_time
            delta_time %= self.single_loop_time

            for i in range(len(self.frame_list)):
                if delta_time - self.frame_list[i]['time'] <= 0:
                    if self.single_run:
                        iters = self.iterations
                        self.iterations = i
                        if i < iters:
                            self.stop = True
                            return False
                    return self.images[self.frame_list[i]['index']]
                delta_time -= self.frame_list[i]['time']
        else:
            return self.image

