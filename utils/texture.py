import json
import random
import time
from utils import DefaultError, get_setting
from json import JSONDecodeError


class Texture:
    """
    Class is used to manage animation and textures. when creating a Texture object give it the path of the image
    (default path is the texture folder) and it will automatically search for a file name like the image but with a
    .json suffix if it finds none the class will always return the loaded image. if it doeas however it will check for
    a following structure:
    {
    "time": 1
    "randomized": false,
    "random_start": false,
    "frames": [
            {
                "index": 5,
                "time": 1
            }
        ]
    }
    "time" is obligatory and determines the default timeout in seconds

    "randomized" is not obligatory and will shuffle all undeclared indexes in "frames". Is False by default

    "random_start" will try to break up the synchronisation between same animations by setting the time_reference back
    by a few seconds and thus starting from a random frame

    "frames" represents the flow in wich each image will be shown. the items inside the list must correspond to the
    stacked images inside the .png or it will throw a TextureError.the order of the items is the chronological order
    of the animation itself.The list itself must not be present. we will generate one using default times.same goes for
    the items inside the list. as long as the number of items is correct any missing argument inside can be autogenerated
    using default times and indexes.

    "index" represents the image index inside the stacked image.png

    "time" represents the timeout for this animation frame
    """

    def __init__(self, image, frametime, randomized=False, random_start=False, single_run=False, set_height=False):
        self.init_time = time.time()
        self.default_time = frametime
        self.single_run = single_run
        self.iterations = 0
        self.image = None
        self.img_str = image
        self.stop = False
        self.seth_bool = False
        if set_height:
            self.seth_bool = True
            self.seth_value = set_height

        self.image = image
        self.height, self.width = self.image.get_height(), self.image.get_width()

        if self.seth_bool:
            self.frame_count = self.height // self.seth_value
        else:
            self.frame_count = self.height // self.width

        self.single_loop_time = self.frame_count * self.default_time

        if self.seth_bool:
            self.images = [self.image.subsurface((0, self.seth_value * i, self.width, self.seth_value)) for i in range(self.frame_count)]
        else:
            self.images = [self.image.subsurface((0, self.width * i, self.width, self.width)) for i in range(self.frame_count)]

        self.frame_list = [{"index": i, "time": self.default_time} for i in range(self.frame_count)]

    def get(self):
        """
        get is used to get the image to display. it will automatically pick the right one based on the time it was initialized
        :return:
        """
        if self.stop: return False
        now = time.time()
        delta_time = now - self.init_time
        delta_time %= self.single_loop_time

        for i in range(len(self.frame_list)):
            if delta_time - self.frame_list[i]['time'] <= 0:
                if self.single_run:
                    iters = self.iterations
                    self.iterations = i
                    if i < iters:
                        self.stop = True
                        return False
                return self.images[self.frame_list[i]['index']]
            delta_time -= self.frame_list[i]['time']
